exports.id=937,exports.ids=[937],exports.modules={8359:()=>{},3739:()=>{},4598:(e,t,o)=>{"use strict";o.d(t,{s:()=>a});var i=o(699);let BookingService=class BookingService{getSupabase(){return(0,i.j)()}async checkBookingConflicts(e){let{property_id:t,check_in:o,check_out:i,exclude_booking_id:a}=e,r=this.getSupabase(),s=r.from("bookings").select("id").eq("property_id",t).in("status",["confirmed","checked_in"]).or(`and(check_in.lte.${i},check_out.gt.${o})`);a&&(s=s.neq("id",a));let{data:n,error:c}=await s;if(c)throw Error(`Failed to check booking conflicts: ${c.message}`);return n.length>0}async calculateBookingAmount(e,t,o){let i=this.getSupabase(),{data:a,error:r}=await i.from("properties").select("base_price").eq("id",e).single();if(r||!a)throw Error("Property not found");let s=new Date(t),n=new Date(o),c=Math.ceil((n.getTime()-s.getTime())/864e5),{data:u}=await i.from("calendar_availability").select("date, custom_price").eq("property_id",e).gte("date",t).lt("date",o).not("custom_price","is",null),d=0,g=new Map(u?.map(e=>[e.date,e.custom_price])||[]);for(let e=0;e<c;e++){let t=new Date(s);t.setDate(t.getDate()+e);let o=t.toISOString().split("T")[0],i=g.get(o)||a.base_price;d+=i}return d}async createBooking(e,t){let o=await this.checkBookingConflicts({property_id:e.property_id,check_in:e.check_in,check_out:e.check_out});if(o)throw Error("Booking conflicts with existing reservation");let i=this.getSupabase(),{data:a,error:r}=await i.from("properties").select("max_guests").eq("id",e.property_id).single();if(r||!a)throw Error("Property not found");if(e.guest_count>a.max_guests)throw Error(`Guest count exceeds maximum allowed (${a.max_guests})`);let s=await this.calculateBookingAmount(e.property_id,e.check_in,e.check_out),n={property_id:e.property_id,guest_id:t,check_in:e.check_in,check_out:e.check_out,guest_count:e.guest_count,total_amount:s,guest_details:e.guest_details,special_requests:e.special_requests,status:"pending"},{data:c,error:u}=await i.from("bookings").insert(n).select().single();if(u)throw Error(`Failed to create booking: ${u.message}`);return this.mapBookingRow(c)}async getBookingById(e){let t=this.getSupabase(),{data:o,error:i}=await t.from("bookings").select(`
        *,
        properties (
          title,
          address,
          owner_id
        )
      `).eq("id",e).single();if(i){if("PGRST116"===i.code)return null;throw Error(`Failed to get booking: ${i.message}`)}return this.mapBookingRow(o)}async getBookings(e={}){let{page:t=1,limit:o=10,property_id:i,guest_id:a,status:r,check_in_from:s,check_in_to:n,sort_by:c="created_at",sort_order:u="desc"}=e,d=this.getSupabase(),g=d.from("bookings").select(`
        *,
        properties (
          title,
          address
        )
      `,{count:"exact"});i&&(g=g.eq("property_id",i)),a&&(g=g.eq("guest_id",a)),r&&(g=g.eq("status",r)),s&&(g=g.gte("check_in",s)),n&&(g=g.lte("check_in",n)),g=g.order(c,{ascending:"asc"===u});let l=(t-1)*o,_=l+o-1;g=g.range(l,_);let{data:p,error:k,count:h}=await g;if(k)throw Error(`Failed to get bookings: ${k.message}`);return{bookings:p?.map(this.mapBookingRow)||[],total:h||0}}async updateBooking(e){let{id:t,...o}=e;if(o.check_in||o.check_out){let e=await this.getBookingById(t);if(!e)throw Error("Booking not found");let i=o.check_in||e.check_in,a=o.check_out||e.check_out,r=await this.checkBookingConflicts({property_id:e.property_id,check_in:i,check_out:a,exclude_booking_id:t});if(r)throw Error("Updated dates conflict with existing reservation");if(o.check_in||o.check_out){let t=await this.calculateBookingAmount(e.property_id,i,a);o.total_amount=t}}if(o.guest_count){let e=await this.getBookingById(t);if(!e)throw Error("Booking not found");let i=this.getSupabase(),{data:a,error:r}=await i.from("properties").select("max_guests").eq("id",e.property_id).single();if(r||!a)throw Error("Property not found");if(o.guest_count>a.max_guests)throw Error(`Guest count exceeds maximum allowed (${a.max_guests})`)}let i=this.getSupabase(),{data:a,error:r}=await i.from("bookings").update(o).eq("id",t).select().single();if(r)throw Error(`Failed to update booking: ${r.message}`);return this.mapBookingRow(a)}async updateBookingStatus(e){let{id:t,to_status:o}=e,i=await this.getBookingById(t);if(!i)throw Error("Booking not found");let a=this.getSupabase(),{data:r,error:s}=await a.from("bookings").update({status:o}).eq("id",t).select().single();if(s)throw Error(`Failed to update booking status: ${s.message}`);return this.mapBookingRow(r)}async cancelBooking(e){let t=await this.getBookingById(e);if(!t)throw Error("Booking not found");if("cancelled"===t.status)throw Error("Booking is already cancelled");if("checked_out"===t.status)throw Error("Cannot cancel completed booking");return this.updateBookingStatus({id:e,from_status:t.status,to_status:"cancelled"})}async deleteBooking(e){let t=this.getSupabase(),{error:o}=await t.from("bookings").delete().eq("id",e);if(o)throw Error(`Failed to delete booking: ${o.message}`)}mapBookingRow(e){return{id:e.id,property_id:e.property_id,guest_id:e.guest_id,check_in:e.check_in,check_out:e.check_out,guest_count:e.guest_count,total_amount:e.total_amount,status:e.status,guest_details:e.guest_details,special_requests:e.special_requests||void 0,payment_intent_id:e.payment_intent_id||void 0,created_at:e.created_at,updated_at:e.updated_at}}};let a=new BookingService},699:(e,t,o)=>{"use strict";o.d(t,{j:()=>createSupabaseServerClient});var i=o(6813),a=o(4596);let createSupabaseServerClient=()=>(0,i.createServerComponentClient)({cookies:a.cookies})}};